# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal 
# numbers are all figurate (polygonal) numbers and are generated by 
# the following formulae:
# 
# Triangle:   P_(3,n)=n(n+1)/2   1, 3, 6, 10, 15, ...
# Square:     P_(4,n)=n^(2)      1, 4, 9, 16, 25, ...
# Pentagonal: P_(5,n)=n(3n-1)/2  1, 5, 12, 22, 35, ...
# Hexagonal:  P_(6,n)=n(2n-1)    1, 6, 15, 28, 45, ...
# Heptagonal: P_(7,n)=n(5n-3)/2  1, 7, 18, 34, 55, ...
# Octagonal:  P_(8,n)=n(3n-2)    1, 8, 21, 40, 65, ...
# 
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has 
# three interesting properties.
# 
#    1. The set is cyclic, in that the last two digits of each number 
#       is the first two digits of the next number (including the last 
#       number with the first).
#    2. Each polygonal type: triangle (P_(3,127)=8128), square
#       (P_(4,91)=8281), and pentagonal (P_(5,44)=2882), is 
#       represented by a different number in the set.
#    3. This is the only set of 4-digit numbers with this property.
# 
# Find the sum of the only ordered set of six cyclic 4-digit numbers 
# for which each polygonal type: triangle, square, pentagonal, 
# hexagonal, heptagonal, and octagonal, is represented by a different 
# number in the set.

from __future__ import division

from math import sqrt, ceil
from functools import partial
from itertools import ifilter, permutations

def triangle(n):
    return n * (n + 1) / 2
def inverse_triangle(n):
    yield ( -1 + sqrt(8 * n + 1) ) / 2
    yield ( -1 - sqrt(8 * n + 1) ) / 2
assert(inverse_triangle(triangle(12345)).next() == 12345)

def square(n):
    return n**2
def inverse_square(n):
    positive = sqrt(n)
    yield positive
    yield -positive
assert(inverse_square(square(12345)).next() == 12345)

def pentagonal(n):
    return n * (3 * n - 1) / 2
def inverse_pentagonal(n):
    yield (1 + sqrt(24 * n + 1)) / 6
    yield (1 - sqrt(24 * n + 1)) / 6
assert(inverse_pentagonal(pentagonal(12345)).next() == 12345)

def hexagonal(n):
    return n * (2 * n - 1)
def inverse_hexagonal(n):
    yield (1 + sqrt(8 * n + 1)) / 4
    yield (1 - sqrt(8 * n + 1)) / 4
assert(inverse_hexagonal(hexagonal(12345)).next() == 12345)

def heptagonal(n):
    return n * (5 * n - 3) / 2
def inverse_heptagonal(n):
    yield (3 + sqrt(40 * n + 9)) / 10
    yield (3 - sqrt(40 * n + 9)) / 10
assert(inverse_heptagonal(heptagonal(12345)).next() == 12345)

def octagonal(n):
    return n * (3 * n - 2)
def inverse_octagonal(n):
    yield (1 + sqrt(3 * n + 1)) / 3
    yield (1 - sqrt(3 * n + 1)) / 3
assert(inverse_octagonal(octagonal(12345)).next() == 12345)

polygonal_functions = [triangle, square, pentagonal, hexagonal, heptagonal, octagonal]
polygonal_inverse_functions = [inverse_triangle, inverse_square, inverse_pentagonal, inverse_hexagonal, inverse_heptagonal, inverse_octagonal]

def polygonal_range(fn, inverse_fn, min_num, max_num):
    for i in xrange(int(ceil(inverse_fn(min_num).next())), int(inverse_fn(max_num).next()) + 1):
        yield int(fn(i)) 

def begins_with_prev_end(current, next, num_digits=2):
    pow10 = 10**num_digits
    return current % pow10 == next // pow10

def find_cyclic_polygonals(number, function_pairs):

    if number != len(function_pairs):
        raise Exception('I pity the foo!')

    polygonal_numbers = dict( (fn.__name__, list(polygonal_range(fn, inverse_fn, 1000, 9999))) 
            for fn, inverse_fn in function_pairs )

    def potentials(test_number, function_pairs):
        fn, inverse_fn = function_pairs[0]

        for poly_num in ifilter(partial(begins_with_prev_end, test_number), polygonal_numbers[fn.__name__]):
            if len(function_pairs) == 1:
                yield (poly_num,)
                continue

            for seq in potentials(poly_num, function_pairs[1:]):
                yield (poly_num,) + seq

    fn, inverse_fn = function_pairs[0]

    for poly_num in polygonal_numbers[fn.__name__]:
        for perm in permutations(function_pairs[1:]):
            for potential in potentials(poly_num, perm):
                if begins_with_prev_end(potential[-1], poly_num):
                    return (poly_num,) + potential

if __name__ == "__main__":
    assert( find_cyclic_polygonals(3, zip(polygonal_functions[:3], polygonal_inverse_functions[:3])) == (8128, 2882, 8281) )

    six_set = find_cyclic_polygonals(6, zip(polygonal_functions[:6], polygonal_inverse_functions[:6]))
    print 'Set:', six_set
    print sum(six_set)
